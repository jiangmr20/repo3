1.List，Map这些collection类，通常加<>用于指定类型，如Map<String, Object>，和List<Map<String, Object>>



2.不要在循环中写sql链接，不然会导致sql链接过多导致变慢。

如何防止此等需求，

解决方案1：一次性全部查出，在java层进行操作；例如要通过循环查出多个list，可以通过巧妙设置pojo类 解决，如工作遇到的问题12：

```xml
<resultMap id="objectDetailMap" type="com.cn21.opmm.domain.gradeCenter.GradeObject">
        <id column="id" jdbcType="INTEGER" property="id" />
        <result column="project_id" jdbcType="INTEGER" property="projectId" />
        <result column="name" jdbcType="VARCHAR" property="name" />
        <result column="model_id" jdbcType="INTEGER" property="modelId" />
        <result column="start_time" jdbcType="TIMESTAMP" property="startTime" />
        <result column="end_time" jdbcType="TIMESTAMP" property="endTime" />
        <result column="status" jdbcType="TINYINT" property="status" />
        <result column="user_dept_id" jdbcType="INTEGER" property="userDeptId" />
        <result column="method" jdbcType="TINYINT" property="method" />
        <result column="is_view_score" jdbcType="TINYINT" property="hasViewScore" />
        <result column="is_view_reason" jdbcType="TINYINT" property="hasViewReason" />
        <result column="userName" jdbcType="VARCHAR" property="userName" />
        <result column="modelName" jdbcType="VARCHAR" property="modelName" />
        <result column="position_id" jdbcType="INTEGER" property="positionId" />
        <result column="dept_code" jdbcType="VARCHAR" property="deptCode" />
        <result column="projectName" jdbcType="VARCHAR" property="projectName" />
        <result column="projectSponsorId" jdbcType="INTEGER" property="projectSponsorId" />
        <result column="gradeRange" jdbcType="VARCHAR" property="gradeRange" />
        <collection property="gradeList" ofType="com.cn21.opmm.domain.gradeCenter.Grade">
            <id column="gId" jdbcType="INTEGER" property="id" />
            <result column="grade_dept_id" jdbcType="INTEGER" property="gradeDeptId" />
            <result column="grade" jdbcType="INTEGER" property="grade" />
            <result column="reason" jdbcType="VARCHAR" property="reason" />
            <result column="gModelDetailId" jdbcType="INTEGER" property="modelDetailId" />
            <result column="gObjId" jdbcType="INTEGER" property="objId" />
            <result column="submit_time" jdbcType="TIMESTAMP" property="submitTime" />
            <result column="gUserDeptId" jdbcType="INTEGER" property="userDeptId" />
            <result column="gPositionId" jdbcType="INTEGER" property="positionId" />
            <result column="gDeptCode" jdbcType="VARCHAR" property="deptCode" />
            <result column="email" jdbcType="VARCHAR" property="email" />
            <result column="gUserName" jdbcType="VARCHAR" property="userName" />
            <result column="prefer_mobile" jdbcType="VARCHAR" property="mobile" />
            <result column="hasGrade" jdbcType="TINYINT" property="hasGrade" />
        </collection>
        <collection property="gradeDeptList" ofType="com.cn21.opmm.domain.gradeCenter.GradeDept">
            <id column="gdId" jdbcType="INTEGER" property="id" />
            <result column="gdObjId" jdbcType="INTEGER" property="objId" />
            <result column="dept_id" jdbcType="INTEGER" property="deptId" />
            <result column="min_num" jdbcType="INTEGER" property="minNum" />
            <result column="max_num" jdbcType="INTEGER" property="maxNum" />
            <result column="deptName" jdbcType="VARCHAR" property="deptName" />
            <result column="gradeCount" jdbcType="INTEGER" property="gradeCount" />
        </collection>
    </resultMap>

```

分析：在collection里，里面可以匹配出list。即本来用inner join 或left join得到的数据是多条（因为笛卡尔积），但用了这个collection，mybatis会自动将多条数据里，GradeObject部分相同的合并，将各个不相同的GradeDept合并到GradeObject的pojo的List<GradeDept>里，整个GradeObject作为一个对象返回出来。



3.业务中有一个需求，需要插入一些新数据，其中name相同的则覆盖。由于id是主键，常规的insert会报错，update又不满足有一些新数据需要插入的需求，以下有几种思路：

a、先找出重复的name的主键id，然后删除这些数据，在重新插入。（缺点，过程繁琐，而且如果是自增id，删除再插入会改变id，如果id需要用则会出现问题）

b、先找出重复的name的主键id，然后根据id讲新数据分成两部分，重复的部分用update，新的部分用插入。（缺点：贼j2麻烦）

c、使用insert语句里的防冲突函数，例子如下：

```xml
<insert id="batchInsertGrade" parameterType="com.cn21.opmm.domain.gradeCenter.Grade">
        insert into tb_grade(id, user_dept_id, grade_dept_id, grade, reason, model_detail_id, obj_id, submit_time, position_id)
        values
        <foreach collection="list" item="item" index="index" separator=",">
            (#{item.id,jdbcType=INTEGER},#{item.userDeptId,jdbcType=INTEGER},
            #{item.gradeDeptId,jdbcType=INTEGER},#{item.grade,jdbcType=INTEGER},
            #{item.reason,jdbcType=VARCHAR},#{item.modelDetailId,jdbcType=INTEGER},
            #{item.objId,jdbcType=INTEGER},#{item.submitTime,jdbcType=TIMESTAMP},
            #{item.positionId,jdbcType=INTEGER})
        </foreach>
        on duplicate key update
        grade = values(grade),
        reason = values(reason),
        submit_time = values(submit_time)
    </insert>
```



4.统计表里的pv和uv

四大指标：PV、UV、VV、IP

https://www.jianshu.com/p/0a15d44405cc

https://baike.baidu.com/item/pv/402?fr=aladdin